说一下内存泄漏？

Java内存泄漏引起的原因：
　　内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费称为
内存泄漏。
　　长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命
周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景。

造成内存泄漏的几种情况：
    1、静态集合类引起内存泄漏
    　　像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的
    对象Object也不能被释放，因为他们也将一直被Vector等引用着。
    2、当集合里面的对象属性被修改后，再调用remove()方法时不起作用。
    3、监听器
    　　在释放对象的时候却没有去删除这些监听器，增加了内存泄漏的机会。
    4、各种连接
    　　比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其
    close（）方法将其连接关闭，否则是不会自动被GC回收的。
    5、内部类和外部模块的引用
    　　内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心
    外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如：
    public void registerMsg(Object b); 这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了
    对该对象的引用，这时候就需要注意模块B 是否提供相应的操作去除引用。
    6、单例模式
    　　不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在
    （以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏。

GC机制？
    算法：标记-清除算法；复制算法；标记整理算法；分代收集算法
    收集器：Serial收集器；ParNew收集器；Parallel Scavenge收集器；CMS收集器；G1收集器

java设计原则？
    单一职责原则；里氏替换原则；依赖倒置原则；接口隔离原则；迪米特原则；开闭原则

==和equals()的区别？
    ==: 判断的是两个对象的地址是否相等（基本数据类型比较的是值，引用数据类型比较的是内存地址）
    equals(): 判断的是两个对象的内容是否相等

变量.equals()，这样写可能会带来什么问题？
    需要对变量做空指针异常处理。因为当变量为空的时候，会报NullPointException异常